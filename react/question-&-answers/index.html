<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="../js.png">
    <title>REACT Concepts, Q&A</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #f9f9f9;
            padding: 20px;
        }

        .qa-container {
            max-width: 800px;
            margin: auto;
        }

        .qa-item {
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-color: #fff;
            transition: all 0.3s ease;
        }

        .question {
            padding: 15px 20px;
            background-color: #007BFF;
            color: white;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question:hover {
            background-color: #0056b3;
        }

        .question::after {
            content: '+';
            font-size: 18px;
            transition: transform 0.3s ease;
        }

        .question.active::after {
            content: '‚àí';
        }

        .answer {
            max-height: 0;
            overflow: hidden;
            padding: 0 20px;
            background-color: #f4f4f4;
            transition: max-height 0.5s ease, padding 0.3s ease;
        }

        .answer.show {
            max-height: 500px; /* Enough for most answers */
            padding: 15px 20px;
            overflow-y: auto;
        }
        .answer ul {
            list-style-type: disc;
            padding-left: 20px;
        }
        .answer ul> li {
            margin-bottom: 10px;
            
        }
        .answer h4 {
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .answer pre {
            background-color: #e8e8e8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        table> thead > tr > th {
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="qa-container">
        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                Webpack
            </div>
            <div class="answer">
                Webpack is a module bundler for modern JavaScript applications. It processes your application‚Äôs files (JavaScript, CSS, images, etc.), resolves their dependencies, and bundles them into one or more output files optimized for the browser
                <p>
                    <h4>Key Features</h4>
                    <ul>
                        <li><b>Module Bundling:</b> Combines multiple files into a single file or smaller chunks for better performance.</li>
                        <li><b>Code Splitting:</b> Allows you to split your code into separate bundles that can be loaded on demand.</li>
                        <li><b>Loaders:</b> Transforms files (e.g., Babel for JavaScript, CSS loaders) before bundling.</li>
                        <li><b>Plugins:</b> Extend Webpack's functionality (e.g., minification, environment variables).</li>
                        <li><b>Development Server:</b> Provides a local server with live reloading during development.</li>
                        <li><b>Tree Shaking:</b> Removes unused code to reduce bundle size.</li>
                        <li><b>Hot Module Replacement (HMR):</b> Updates modules in the browser without a full reload.</li>
                    </ul>
                </p>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                Vite
            </div>
            <div class="answer">
                Vite is a modern frontend build tool that aims to provide a faster and leaner development experience. It uses native ES modules in the browser for dev, and Rollup for bundling in production.
                <p>
                    <h4>Key Features</h4>
                    <ul>
                        <li><b>Instant Server Start:</b> Uses native ESM for fast server start-up.</li>
                        <li><b>Hot Module Replacement (HMR):</b> Provides fast updates during development without full page reloads.</li>
                        <li><b>Optimized Build:</b> Uses Rollup for production builds, ensuring efficient code splitting and tree shaking.</li>
                        <li><b>Plugin Ecosystem:</b> Supports a wide range of plugins for various tasks (e.g., TypeScript, JSX, CSS).</li>
                        <li><b>Framework Agnostic:</b> Works with various frameworks like React, Vue, Svelte, etc.</li>
                    </ul>
                </p>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                key advantages of using react in large scale apps
            </div>
            <div class="answer">
                <ul>
                    <li><b>Component-Based Architecture:</b> React's component-based structure promotes reusability and maintainability, making it easier to manage large codebases.</li>
                    <li><b>Virtual DOM:</b> React's efficient rendering with the virtual DOM minimizes direct manipulation of the actual DOM, leading to better performance.</li>
                    <li><b>Unidirectional Data Flow:</b> This makes it easier to understand how data changes in the application, which is crucial for debugging and maintaining large applications.</li>
                    <li><b>Strong Community and Ecosystem:</b> A vast ecosystem of libraries, tools, and community support helps in building complex applications efficiently.</li>
                    <li><b>State Management Libraries:</b> Libraries like Redux or MobX help manage state in large applications, making it easier to handle complex data flows.</li>
                    <li><b>Testing Tools:</b> React has robust testing libraries (like Jest and React Testing Library) that facilitate unit and integration testing in large applications.</li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
               Ways to optimize any react app
            </div>
            <div class="answer">
                <ul>
                    <li><b>Code Splitting:</b> Use dynamic imports to split your code into smaller chunks, loading only what is necessary.</li>
                    <li><b>Memoization:</b> Use React.memo and useMemo to prevent unnecessary re-renders of components and expensive calculations.</li>
                    <li><b>Lazy Loading:</b> Load components or images only when they are needed, improving initial load time.</li>
                    <li><b>Use Pure Components:</b> Implement PureComponent or React.memo to avoid re-rendering components that do not change.</li>
                    <li><b>Optimize State Management:</b> Use local state where possible, and avoid unnecessary global state updates.</li>
                    <li><b>Debounce and Throttle:</b> For events like scrolling or typing, use debounce or throttle techniques to limit the frequency of updates.</li>
                    <li><b>Use Production Builds:</b> Always use production builds for deployment to benefit from optimizations like minification and dead code elimination.</li>
                    <li><b>Profiling:</b> Use React's built-in Profiler to identify performance bottlenecks and optimize rendering.</li>
                    <li><b>Avoid Inline Functions:</b> Define functions outside of render methods to prevent them from being recreated on every render.</li>
                    <li><b>Use CSS-in-JS Libraries:</b> Libraries like styled-components or Emotion can help optimize styles and reduce the size of CSS files.</li>
                    <li><b>Server-Side Rendering (SSR):</b> Use SSR to improve initial load times and SEO for large applications.</li>
                    <li><b>Use Web Workers:</b> Offload heavy computations to web workers to keep the main thread responsive.</li>
                    <li><b>Optimize Images:</b> Use responsive images and modern formats (like WebP) to reduce image sizes.</li>
                    <li><b>Reduce Bundle Size:</b> 
                        <ul>
                            <li>Use tree shaking to remove unused code</li>
                            <li>Analyze bundle size with tools like Webpack Bundle Analyzer</li>
                            <li>Use code splitting to load only necessary parts of the application</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                React Hooks
            </div>
            <div class="answer">
                <ul>
                    <li>Hooks are functions that let you use state and other React features without writing a class</li>
                    <li>They allow you to manage state, lifecycle methods, and side effects in functional components</li>
                    <li>Common hooks include useState, useEffect, useContext, useReducer and custom hooks</li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                React Context
            </div>
            <div class="answer">
                <ul>
                    <li>Context provides a way to pass data through the component tree without having to pass props down manually at every level</li>
                    <li>It is useful for global data like themes, user authentication, and settings</li>
                    <li>Created using React.createContext() and accessed with useContext or Context.Consumer</li>
                    <li>Helps avoid "prop drilling" where props are passed through many layers of components</li>
                    <li>Can be used with useReducer for state management in larger applications</li>
                </ul>

                <h4>Example</h4>
                <pre>
                // CounterContext.js
                import { createContext, useContext, useState } from "react";

                const CounterContext = createContext();

                export const CounterProvider = ({ children }) => {
                    const [count, setCount] = useState(0);

                    const increment = () => setCount((prev) => prev + 1);
                    const decrement = () => setCount((prev) => prev - 1);

                    return (
                        <CounterContext.Provider value={{ count, increment, decrement }}>
                        {children}
                        </CounterContext.Provider>
                    );
                };

                export const useCounter = () => useContext(CounterContext);


                // main.jsx or index.js
                import React from "react";
                import ReactDOM from "react-dom/client";
                import App from "./App";
                import { CounterProvider } from "./CounterContext";

                ReactDOM.createRoot(document.getElementById("root")).render(<CounterProvider><App /></CounterProvider>);

                // CounterButtons.jsx
                import React from "react";
                import { useCounter } from "./CounterContext";

                const CounterButtons = () => {
                    const { increment, decrement } = useCounter();

                    return (
                        <div>
                            <button onClick={increment}>Increment</button>
                            <button onClick={decrement}>Decrement</button>
                        </div>
                    );
                };

                export default CounterButtons;
                </pre>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                useState v/s useReducer
            </div>
            <div class="answer">
                <h4>useState</h4>
                <ul>
                    <li>useState is a Hook that lets you add state to functional components.</li>
                    <li>It is suitable for simple state management where the state is not complex or does not depend on previous state.</li>
                    <li>Returns an array with the current state and a function to update it.</li>
                    <li>Example: const [count, setCount] = useState(0);</li>
                </ul>

                <h4>useReducer</h4>
                <ul>
                    <li>useReducer is a Hook that lets you manage complex state logic in functional components.</li>
                    <li>It is suitable for state that involves multiple sub-values or when the next state depends on the previous state.</li>
                    <li>Returns an array with the current state and a dispatch function to update it based on actions.</li>
                    <li>Example: const [state, dispatch] = useReducer(reducer, initialState);</li>
                    <li>Reducer function takes the current state and an action, and returns the new state.</li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                useEffect v/s useLayoutEffect
            </div>
            <div class="answer">
                <h4>useEffect</h4>
                <ul>
                    <li>useEffect is a Hook that lets you perform side effects in functional components.</li>
                    <li>It runs after the render phase, allowing the DOM to be updated before the effect runs.</li>
                    <li>Suitable for operations like data fetching, subscriptions, or manually changing the DOM.</li>
                    <li>Fires after the DOM has been painted</li>
                    <li>Example: useEffect(() => { /* effect code */ }, [dependencies]);</li>
                </ul>

                <h4>useLayoutEffect</h4>
                <ul>
                    <li>useLayoutEffect is similar to useEffect but runs synchronously after all DOM mutations.</li>
                    <li>It is useful for reading layout from the DOM and synchronously re-rendering.</li>
                    <li>Runs before the browser has a chance to paint, ensuring that the effect is applied before the user sees any changes.</li>
                    <li>Example: useLayoutEffect(() => { /* effect code */ }, [dependencies]);</li>
                    <li>Use it when you need to perform measurements or DOM manipulations that should not be visible to the user until they are complete.</li>
                </ul>

                <pre>
                Render Phase
                |
                |-- useLayoutEffect (sync)
                |
                |-- Browser Paint
                |
                |-- useEffect (async)
                </pre>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                lazy loading in react with practical examples
            </div>
            <div class="answer">
                <p>Lazy loading in React is a performance optimization technique that allows you to load components or modules only when they are needed, rather than at initial page load. This reduces the size of the JavaScript bundle and improves app performance‚Äîespecially in large applications.</p>
                
                <h4>1. React.lazy and Suspense</h4>
                <ul>
                    <li>Components are not loaded initially.</li>
                    <li>They are fetched dynamically when the route is visited.</li>
                    <li>You see "Loading..." until the actual component loads.</li>
                </ul>
                <pre>
                import React, { lazy, Suspense } from 'react';
                import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';

                const Home = lazy(() => import('./components/Home'));
                const About = lazy(() => import('./components/About'));

                function App() {
                    return (
                        <Router>
                            <nav>
                                <Link to="/">Home</Link>
                                <Link to="/about">About</Link>
                            </nav>

                            {/* Suspense shows fallback until the component is loaded */}
                            <Suspense fallback="Loading...">
                                <Routes>
                                <Route path="/" element="Home Component" />
                                <Route path="/about" element="About Component" />
                                </Routes>
                            </Suspense>
                        </Router>
                    );
                }
                </pre>

                <h4>2. Lazy Load Components on Scroll (Using IntersectionObserver)</h4>
                <ul>
                    <li>Components are not loaded initially.</li>
                    <li>They are fetched dynamically when the route is visited.</li>
                    <li>You see "Loading..." until the actual component loads.</li>
                </ul>
                <pre>
                // LazyComponentWrapper.js
                import React, { useRef, useState, useEffect } from 'react';

                export default function LazyComponentWrapper({ children }) {
                    const ref = useRef();
                    const [isVisible, setVisible] = useState(false);

                    useEffect(() => {
                        const observer = new IntersectionObserver(([entry]) => {
                        if (entry.isIntersecting) setVisible(true);
                        });

                        if (ref.current) observer.observe(ref.current);
                        return () => observer.disconnect();
                    }, []);

                    return <div ref={ref}>{isVisible ? children : null}</div>;
                }


                // App.js
                import React, { lazy, Suspense } from 'react';
                import LazyComponentWrapper from './LazyComponentWrapper';

                const Footer = lazy(() => import('./components/Footer'));

                function App() {
                    return (
                        <div>
                            <h1>Scroll down to load footer...</h1>

                            <LazyComponentWrapper>
                                <Suspense fallback="Loading footer...">
                                    <Footer></Footer>
                                </Suspense>
                            </LazyComponentWrapper>
                        </div>
                    );
                }
                </pre>

                <h4>3. React Router Lazy Routes (React 18+)</h4>
                <ul>
                    <li>Components are not loaded initially.</li>
                    <li>They are fetched dynamically when the route is visited.</li>
                    <li>You see "Loading..." until the actual component loads.</li>
                </ul>
                <pre>
                import { createBrowserRouter, RouterProvider, lazyRoute } from 'react-router-dom';

                const router = createBrowserRouter([
                    {
                        path: '/',
                        lazy: () => import('./routes/Home'),
                    },
                    {
                        path: '/about',
                        lazy: () => import('./routes/About'),
                    }
                ]);

                <RouterProvider router={router} />
                </pre>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                difference between useRef and createRef
            </div>
            <div class="answer">
                <h4>üß† Core Concept</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>useRef</th>
                            <th>createRef</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Used in</td>
                            <td>‚úÖ Function components</td>
                            <td>‚úÖ Class components, also usable in function components</td>
                        </tr>
                        <tr>
                            <td>Lifecycle</td>
                            <td>üìå Persistent across re-renders</td>
                            <td>‚ùå Re-created on every render if used inside function</td>
                        </tr>
                        <tr>
                            <td>Primary Use</td>
                            <td>DOM access, mutable variables, instance tracking</td>
                            <td>DOM access (mostly in class components)</td>
                        </tr>
                        <tr>
                            <td>Maintains same ref object?</td>
                            <td>‚úÖ Yes</td>
                            <td>‚ùå No (creates new object each time if called inside a function)</td>
                        </tr>
                    </tbody>
                </table>

                <br/><br/>
                <h4>üß© Practical Examples of useRef</h4>
                <ul>
                    <li>inputRef persists across renders</li>
                    <li>inputRef.current does not cause re-renders when changed.</li>
                </ul>
                <pre>
                import { useRef, useEffect } from 'react';

                function InputFocus() {
                    const inputRef = useRef(null);

                    useEffect(() => {
                        inputRef.current.focus(); // auto-focus the input
                    }, []);

                    return <input ref={inputRef} />
                }
                </pre>

                <h4>üß© Practical Examples of createRef</h4>
                <ul>
                    <li>Used in class components to access DOM elements.</li>
                    <li>Creates a new ref object on each render if used inside a function component.</li>
                </ul>
                <pre>
                import React, { Component, createRef } from 'react';

                class MyComponent extends Component {
                    constructor() {
                        super();
                        this.inputRef = createRef();
                    }

                    componentDidMount() {
                        this.inputRef.current.focus();
                    }

                    render() {
                        return <input ref={this.inputRef} />;
                    }
                }
                </pre>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                Reconciliation in React
            </div>
            <div class="answer">
                <p>Reconciliation is the process React uses to determine what parts of the DOM need to be updated when the component‚Äôs state or props change.</p>
                <h4>Key Concepts</h4>
                <ul>
                    <li><b>Virtual DOM:</b> React creates a lightweight copy of the actual DOM, known as the Virtual DOM, to optimize updates.</li>
                    <li><b>Diffing Algorithm:</b> React compares the new Virtual DOM with the previous one to identify changes.</li>
                    <li><b>Efficient Updates:</b> Only the parts of the DOM that have changed are updated, minimizing performance overhead.</li>
                    <li><b>Keys:</b> Using unique keys for list items helps React identify which items have changed, been added, or removed.</li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                secure a react app i.e. vulnerabilities and best practices
            </div>
            <div class="answer">
                <h4>Common Vulnerabilities</h4>
                <ul>
                    <li><b>Cross-Site Scripting (XSS):</b> Injecting malicious scripts into web pages viewed by other users.</li>
                    <li><b>Cross-Site Request Forgery (CSRF):</b> Forcing a user to execute unwanted actions on a different site where they are authenticated.</li>
                    <li><b>Insecure Direct Object References:</b> Exposing sensitive data through predictable URLs or identifiers.</li>
                    <li><b>Server-Side Rendering (SSR) Vulnerabilities:</b> Risks associated with rendering user-generated content on the server.</li>
                </ul>

                <h4>Best Practices</h4>
                <ul>
                    <li><b>Input Validation:</b> Always validate and sanitize user inputs to prevent XSS attacks.</li>
                    <li><b>Use HTTPS:</b> Ensure all data is transmitted securely over HTTPS to prevent eavesdropping</li>
                    <li><b>Content Security Policy (CSP):</b> Implement CSP headers to restrict the sources of content that can be loaded by the browser.</li>
                    <li><b>Authentication and Authorization:</b> Use secure authentication methods (e.g, OAuth, JWT) and ensure proper authorization checks are in place.</li>
                    <li><b>Secure Dependencies:</b> Regularly update dependencies and use tools like npm audit to check for known vulnerabilities.</li>
                    <li><b>Environment Variables:</b> Store sensitive information like API keys and secrets in environment variables, not in the codebase.</li>
                    <li><b>Rate Limiting:</b> Implement rate limiting to prevent abuse of APIs and endpoints.</li>
                    <li><b>Use Security Libraries:</b> Utilize libraries like Helmet to set secure HTTP headers in your React app.</li>
                    <li><b>Regular Security Audits:</b> Conduct regular security audits and penetration testing to identify and fix vulnerabilities.</li>
                    <li><b>Monitor and Log:</b> Implement logging and monitoring to detect suspicious activities and respond to incidents promptly.</li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                accessibility in react, how to achieve a11y?
            </div>
            <div class="answer">
                <p>A11y is a numeronym for ‚Äúaccessibility‚Äù (a + 11 characters + y). It ensures:</p>
                <ul>
                    <li>Web applications are usable by people with disabilities.</li>
                    <li>Includes visual, auditory, physical, speech, cognitive, language, learning, and neurological disabilities.</li>
                    <li>Blind users can use screen readers</li>
                    <li>Keyboard users can navigate fully</li>
                    <li>Users with motion or cognitive issues aren‚Äôt blocked by poor UX</li>
                </ul>

                <h4>Best Practices for Achieving A11y in React</h4>
                <p>1.Semantic HTML</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Use This ‚úÖ</th>
                                <th>Instead of ‚ùå</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>&lt;button&gt;</td>
                                <td>&lt;div onClick&gt;&lt;/div&gt;</td>
                            </tr>
                            <tr>
                                <td>&lt;label for="input"&gt;</td>
                                <td>&lt;span&gt;</td>
                            </tr>
                            <tr>
                                <td>&lt;nav&gt;, &lt;header&gt;</td>
                                <td>&lt;div&gt;</td>
                            </tr>
                            <tr>
                                <td>&lt;ul&gt;&lt;li&gt;</td>
                                <td>&lt;div&gt;</td>
                            </tr>
                        </tbody>
                    </table>
                <p>2. ARIA Roles and Attributes</p>
                <ul>
                    <li>Use ARIA roles to enhance accessibility for custom components.</li>
                    <li>Example: <code>&lt;div role="button" aria-pressed="false"&gt;</code></li>
                    <li>Use ARIA attributes like <code>aria-label</code>, <code>aria-labelledby</code>, and <code>aria-describedby</code> to provide additional context.</li>
                </ul>
                <p>3. Keyboard Navigation</p>
                <ul>
                    <li>Ensure all interactive elements are focusable and navigable using the keyboard.</li>
                    <li>Use <code>tabIndex</code> to control focus order.</li>
                    <li>Implement keyboard event handlers for custom components (e.g., handling Enter key for buttons).</li>
                </ul>
                <p>4. Focus Management</p>
                <ul>    
                    <li>Manage focus programmatically when components mount or update.</li>
                    <li>Use <code>useRef</code> to set focus on specific elements.</li>
                    <li>Example: <code>inputRef.current.focus()</code></li>
                </ul>
                <p>5. Color Contrast</p>
                <ul>
                    <li>Ensure sufficient color contrast between text and background (at least 4.5:1 for normal text).</li>
                    <li>Use tools like Lighthouse or a11y color contrast checkers to validate contrast ratios.</li>
                </ul>
                <p>6. Alt Text for Images</p>
                <ul>
                    <li>Provide descriptive alt text for all images using the <code>alt</code> attribute.</li>
                    <li>For decorative images, use an empty alt attribute (<code>alt=""</code>) to prevent screen readers from reading them.</li>
                </ul>
                <p>7. Forms and Labels</p>
                <ul>
                    <li>Use <code>&lt;label&gt;</code> elements to associate labels with form controls.</li>
                    <li>Ensure all form fields have associated labels for screen readers.</li>
                    <li>Use <code>aria-required</code> for required fields and <code>aria-invalid</code> for validation errors.</li>
                </ul>
                <p>8. Testing for Accessibility</p>
                <ul>
                    <li>Use tools like Axe, Lighthouse, or React A11y to test your application for accessibility issues.</li>
                    <li>Conduct manual testing with screen readers (e.g., NVDA, VoiceOver) to ensure a good user experience.</li>
                    <li>Involve users with disabilities in testing to get real feedback on accessibility.</li>
                </ul>
                <p>9. Use Accessibility Libraries</p>
                <ul>
                    <li>Use libraries like React A11y, Reach UI, or Material-UI that provide built-in accessibility features.</li>
                    <li>These libraries often follow best practices and help you build accessible components easily.</li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                React debugging tools and techniques
            </div>
            <div class="answer">
                <p>
                    Debugging is a crucial part of React development. To find and fix issues efficiently, developers use a combination of tools, techniques, and best practices.
                </p>
                <h4>1. React Developer Tools</h4>
                <ul>
                    <li>Browser extension for Chrome and Firefox.</li>
                    <li>Allows you to inspect React component hierarchies, props, state, and hooks.</li>
                    <li>Helps identify performance bottlenecks with the Profiler tab.</li>
                </ul>
                <h4>2. Console Logging</h4>
                <ul>
                    <li>Use <code>console.log()</code> to output variable values, component states, and props.</li>
                    <li>Helpful for quick debugging and understanding the flow of data.</li>
                    <li>Use <code>console.error()</code> for logging errors and exceptions.</li>
                </ul>
                <h4>3. Breakpoints and Debugging in Browser DevTools</h4
                <ul>
                    <li>Set breakpoints in your JavaScript code to pause execution and inspect variables.</li>
                    <li>Use the Sources tab in Chrome DevTools or Firefox Developer Edition.</li>
                    <li>Step through code line by line to understand the flow and identify issues.</li>
                </ul>
                <h4>4. Error Boundaries</h4>
                <ul>
                    <li>Use Error Boundaries to catch JavaScript errors in components and display a fallback UI.</li>
                    <li>Implement <code>componentDidCatch</code> or use the <code>ErrorBoundary</code> component.</li>
                    <li>Helps prevent the entire app from crashing due to an error in a single component.</li>
                </ul>
                <h4>5. Linting and Code Quality Tools</h4>
                <ul>
                    <li>Use ESLint with React plugins to catch common errors and enforce coding standards.</li>
                    <li>Helps maintain code quality and consistency across the codebase.</li>
                    <li>Integrate with your IDE for real-time feedback while coding.</li>
                </ul>
                <h4>6. Unit Testing</h4>
                <ul>
                    <li>Write unit tests using Jest and React Testing Library to catch bugs early.</li>
                    <li>Test components in isolation to ensure they behave as expected.</li>
                    <li>Use snapshot testing to track changes in component output over time.</li>
                </ul>
                <h4>7. Profiling and Performance Monitoring</h4>
                <ul>
                    <li>Use the Profiler tab in React Developer Tools to analyze component rendering performance.</li>
                    <li>Identify components that take too long to render or re-render unnecessarily.</li>
                    <li>Optimize performance by memoizing components, using React.memo, and avoiding unnecessary state updates.</li>
                </ul>
                <h4>8. Network Monitoring</h4>
                <ul>
                    <li>Use the Network tab in browser DevTools to monitor API requests and responses.</li>
                    <li>Check for failed requests, response times, and data formats.</li>
                    <li>Helps identify issues with data fetching and API integration.</li>
                </ul>
                <h4>9. Third-Party Debugging Tools</h4>
                <ul>
                    <li>Use tools like Sentry or LogRocket for error tracking and session replay.</li>
                    <li>These tools help capture errors in production and provide insights into user interactions.</li>
                    <li>Useful for diagnosing issues that occur in real-world usage.</li>
                </ul>
                <h4>10. Best Practices</h4>
                <ul>
                    <li>Keep components small and focused to make debugging easier.</li>
                    <li>Use descriptive names for variables, functions, and components to improve readability.</li>
                    <li>Document your code with comments to explain complex logic or decisions.</li>
                    <li>Regularly review and refactor code to maintain quality and reduce complexity.</li>
                </ul>
            </div>
        </div>

        <div class="qa-item">
            <div class="question" onclick="toggleAnswer(this)">
                hydration in server side rendering
            </div>
            <div class="answer">
                <p>Hydration is the process by which React attaches event listeners and makes a server-rendered static HTML page interactive on the client side.</p>
                <h4>Key Concepts</h4>
                <ul>
                    <li><b>Server-Side Rendering (SSR):</b> The initial HTML is generated on the server and sent to the client.</li>
                    <li><b>Hydration:</b> React takes over the static HTML and attaches event listeners, making it interactive.</li>
                    <li><b>Performance:</b> Hydration can improve performance by reducing the time to first paint, as the initial HTML is already rendered.</li>
                    <li><b>Consistency:</</b> Ensures that the client-side React app matches the server-rendered HTML to avoid mismatches.</li>
                    <li><b>ReactDOM.hydrate:</b> Used to hydrate the server-rendered HTML instead of ReactDOM.render.</li>
                </ul>

                <h4>Example</h4>
                <pre>
                // server.js
                import express from 'express';
                import ReactDOMServer from 'react-dom/server';
                import App from './App';

                const app = express();

                app.get('*', (req, res) => {
                const html = ReactDOMServer.renderToString(<App />);
                res.send(`
                    <!DOCTYPE html>
                    <html>
                    <head><title>React SSR</title></head>
                    <body>
                        <div id="root">${html}</div>
                        <script src="/bundle.js"></script>
                    </body>
                    </html>
                `);
                });
                app.listen(3000, () => {
                    console.log('Server is running on http://localhost:3000');
                });

                // client.js
                import React from 'react';
                import { hydrateRoot } from 'react-dom/client';
                import App from './App';

                hydrateRoot(document.getElementById('root'), <App />);
                </pre>

                <h4>Errors</h4>
                <ul>
                    <li><b>Mismatch Errors:</b> Occur when the server-rendered HTML does not match the client-side React tree.</li>
                    <li><b>Console Warnings:</b> React will log warnings in the console if there are discrepancies between server and client rendering.</li>
                    <li><b>Performance Issues:</b> If hydration takes too long, it can lead to a poor user experience.</li>
                    <li><b>Debugging:</b> Use React Developer Tools to inspect the component tree and identify hydration issues.</li>
                </ul>

                <h4>Solution Tips</h4>
                <ul>
                    <li>Ensure that the server and client render the same components and data.</li>
                    <li>Use consistent state management on both server and client sides.</li>
                    <li>Check for any side effects or asynchronous operations that may cause discrepancies.</li>
                    <li>Use <code>ReactDOM.hydrate</code> instead of <code>ReactDOM.render</code> for hydration.</li>
                    <li>Test your application thoroughly to catch any hydration issues early in development.</li>
                </ul>
            </div>
    </div>


    <script>
        document.querySelectorAll('.question').forEach((question) => {
            question.addEventListener('click', () => {
                // Optional: close all others (accordion effect)
                document.querySelectorAll('.question').forEach(q => {
                    if (q !== question) q.classList.remove('active');
                });

                document.querySelectorAll('.answer').forEach(a => {
                    if (a !== question.nextElementSibling) a.classList.remove('show');
                });

                // Toggle current
                question.classList.toggle('active');
                const answer = question.nextElementSibling;
                answer.classList.toggle('show');
            });
        });
</script>
</body>
</html>
